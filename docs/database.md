## Database schemas

The database is organized into several domains, each containing related tables.

I respected a few naming conventions to keep things consistent:
- Table names are plural and use snake_case (e.g., `event_attendees`);
- Sub-tables are double underscores (e.g., `ruleset__descriptions`);
- Pluralization and singular/plural usage is consistent across entities and relationships (e.g., `tournament_participants` for multiple participants, `tournament_registration` for a single registration);
- Maintain referential integrity with foreign keys and cascading rules.

About indexes:
- Postgres defaults to a btree index when you omit the index method; you do not have to specify it;
- Use btree in almost all cases (range queries, ordering, equality, prefix searches). It's versatile and the recommended choice for columns like `associate_type`;
- Hash indexes are only for equality checks. They are less flexible, rarely necessary, and not recommended for general use.
- The recommendation is: keep the current indexes as btrees (either implicit or explicit). Use hash only if you have a proven, narrow-case need for equality-only lookups and have tested performance.

About database extensions:
- The `pgcrypto` extension is used for generating UUIDs with `gen_random_uuid()`;
- The `pg_trgm` extension is used for fuzzy text search capabilities, particularly in the `pauperwave_associates` table;
- The `unaccent` extension is used to create accent-insensitive text search indexes.

```sql
-- Enable necessary extensions
CREATE EXTENSION IF NOT EXISTS pgcrypto WITH SCHEMA extensions;
CREATE EXTENSION IF NOT EXISTS pg_trgm WITH SCHEMA extensions;
CREATE EXTENSION IF NOT EXISTS unaccent WITH SCHEMA extensions;
```

Below is an overview of the main domains and their associated tables:

### 0. Blog posts domain

- `blog_posts`: Stores blog posts with fields for title, content, author, and timestamps.

```sql
-- 1. Table definition
create table public.blog_posts (
  id bigint generated by default as identity not null,
  uuid uuid not null default gen_random_uuid (),
  
  title text not null,
  content text not null,
  author_uuid uuid not null,
  
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone null,
  
  constraint blog_posts_pkey primary key (id),
  constraint blog_posts_uuid_key unique (uuid),
  constraint blog_posts_author_uuid_fkey foreign KEY (author_uuid) references players (uuid) on update CASCADE on delete RESTRICT
) TABLESPACE pg_default;
-- 2. Indexes for faster lookups
create index IF not exists idx_blog_posts_author_uuid
  on public.blog_posts using btree (author_uuid) TABLESPACE pg_default;
```

### 1. Pauperwave domain

- `pauperwave_associates`: Stores information about associates in the PauperWave community.

```sql
-- 1. Table definition
CREATE TABLE public.pauperwave_associates (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  uuid uuid NOT NULL DEFAULT gen_random_uuid(),

  request_date timestamp with time zone NOT NULL,
  association_date timestamp with time zone NULL,
  pauperwave_associate_number text NULL,

  consent_data boolean NOT NULL DEFAULT false,
  consent_social boolean NOT NULL DEFAULT false,
  has_read_statute boolean NOT NULL DEFAULT false,
  has_acknowledged_surveillance_notice boolean NOT NULL DEFAULT false,

  associate_type text NOT NULL,

  name text NOT NULL,
  surname text NOT NULL,
  tax_code text NULL,
  phone_number text NOT NULL,
  email text NOT NULL,

  born_location text NULL,
  born_date date NOT NULL,
  born_province text NULL,
  born_state text NULL,

  residency_address text NOT NULL,
  residency_city text NOT NULL,
  residency_province text NOT NULL,
  residency_cap text NOT NULL,
  mtgo_nickname text NULL,
  mtga_nickname text NULL,

  CONSTRAINT pauperwave_associates_pkey PRIMARY KEY (id),
  CONSTRAINT pauperwave_associates_phone_number_key UNIQUE (phone_number),
  CONSTRAINT pauperwave_associates_email_key UNIQUE (email),
  CONSTRAINT pauperwave_associates_tax_code_key UNIQUE (tax_code),
  CONSTRAINT pauperwave_associates_pauperwave_associate_number_key UNIQUE (pauperwave_associate_number),
  CONSTRAINT pauperwave_associates_uuid_key UNIQUE (uuid)
) TABLESPACE pg_default;

-- 2. Indexes for faster lookups
-- Soci attivi
create index if not exists idx_pwa_associates_active
  on pauperwave_associates (association_date)
  where association_date is not null;

CREATE INDEX IF NOT EXISTS idx_pauperwave_associates_associate_type
  ON public.pauperwave_associates (associate_type);
CREATE INDEX IF NOT EXISTS idx_pauperwave_associates_residency_city
  ON public.pauperwave_associates (residency_city);
CREATE INDEX IF NOT EXISTS idx_pauperwave_associates_born_date
  ON public.pauperwave_associates (born_date);

-- Fuzzy search indexes (using pg_trgm extension)
-- Create trigram GIN indexes on surname and name (accent-insensitive, case-insensitive)
CREATE INDEX IF NOT EXISTS idx_associates_surname_unaccent_trgm
  ON public.pauperwave_associates
  USING gin (lower(unaccent(coalesce(surname,''))) gin_trgm_ops);
CREATE INDEX IF NOT EXISTS idx_associates_name_unaccent_trgm
  ON public.pauperwave_associates
  USING gin (lower(unaccent(coalesce(name,''))) gin_trgm_ops);
-- Combined index for fullname search (surname + name) trigram index (accent-insensitive):
CREATE INDEX IF NOT EXISTS idx_pauperwave_associates_fullname_unaccent_trgm
  ON public.pauperwave_associates
  USING gin ((lower(unaccent(coalesce(name, '') || ' ' || coalesce(surname, '')))) gin_trgm_ops);

-- 3. Enable Row-Level Security
ALTER TABLE public.pauperwave_associates ENABLE ROW LEVEL SECURITY;
```

Notes:
- `UNIQUE` constraints (`phone_number`, `email`, `tax_code`, `pauperwave_associate_number`, `uuid`) already create unique indexes, no extra index needed for those;
- `pauperwave_associate_number` is `text unique null`. Be aware: in Postgres, multiple NULLs are allowed in a `unique` column.

```sql
-- Example search: prioritize surname similarity, then name similarity
-- Replace 'search_surname' and 'search_name' with your input values
WITH params AS (
  SELECT
    lower(unaccent('search_surname')) AS s_surname,
    lower(unaccent('search_name'))   AS s_name
)
SELECT a.*, 
  similarity(lower(unaccent(coalesce(a.surname,''))), p.s_surname) AS surname_score,
  similarity(lower(unaccent(coalesce(a.name,''))), p.s_name)       AS name_score
FROM public.pauperwave_associates a, params p
WHERE (lower(unaccent(coalesce(a.surname,''))) % p.s_surname) -- trigram match on surname (fast via index)
   OR (lower(unaccent(coalesce(a.name,''))) % p.s_name)       -- fallback: match on name
ORDER BY surname_score DESC, name_score DESC
LIMIT 5;
```

- `pauperwave_associate_renewals`: Tracks renewals for PauperWave associates.

```sql
-- 1. Table definition
create table public.pauperwave_associate_renewals (
  id bigint generated by default as identity not null,
  uuid uuid not null default gen_random_uuid (),
  associate_uuid uuid not null,
  
  renewal_year smallint not null,
  renewal_date date not null default CURRENT_DATE,
  
  constraint pauperwave_membership_renewals_pkey primary key (id),
  constraint pauperwave_associate_renewals_uuid_key unique (uuid),
  constraint pauperwave_associate_renewals_associate_uuid_fkey
    foreign KEY (associate_uuid)
    references pauperwave_associates (uuid)
    on update CASCADE
    on delete RESTRICT
) TABLESPACE pg_default;

-- 2. Indexes for faster lookups
create index IF not exists idx_pauperwave_renewals_associate_uuid
  on public.pauperwave_associate_renewals using btree (associate_uuid) TABLESPACE pg_default;

-- 3. Enable Row-Level Security
ALTER TABLE public.pauperwave_associate_renewals ENABLE ROW LEVEL SECURITY;
```

- `pauperwave_payments`: Manages payments related to PauperWave services.

```sql
-- 1. Table definition
create table public.pauperwave_payments (
  id bigint generated by default as identity not null,
  uuid uuid not null default gen_random_uuid (),
  
  associate_id bigint null,
  payer_name text null,
  payer_surname text null,
  payer_email text null,
  payer_tax_code text null,
  
  payment_date timestamp with time zone not null default now(),
  payment_amount numeric(10, 2) not null default 0,
  payment_method text not null default 'Cash'::text,
  received_by text not null,
  payment_type text not null default 'Donation'::text,
  
  event_name text null,
  notes text not null default ''::text,
  
  constraint pauperwave_payments_pkey primary key (id),
  constraint fk_associate foreign KEY (associate_id) references pauperwave_associates (id) on update CASCADE on delete RESTRICT,
  constraint fk_pauperwave_payments_associate_id foreign KEY (associate_id) references pauperwave_associates (id) on delete set null,
  constraint ck_payer_info check (
    (
      (associate_id is not null)
      or (
        (payer_name is not null)
        and (payer_surname is not null)
        and (payer_email is not null)
      )
    )
  ),
  constraint ck_payment_method check (
    (
      payment_method = any (array['PayPal'::text, 'POS'::text, 'Cash'::text])
    )
  ),
  constraint ck_payment_type check (
    (
      payment_type = any (
        array[
          'Association Fee'::text,
          'Donation'::text,
          'Event'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

-- 2. Indexes for faster lookups
create index IF not exists idx_pauperwave_payments_associate_id on public.pauperwave_payments using btree (associate_id) TABLESPACE pg_default;

-- 3. Enable Row-Level Security
ALTER TABLE public.pauperwave_payments ENABLE ROW LEVEL SECURITY;
```

**Note**: The `pauperwave_payments` table includes a check constraint (`ck_payer_info`) to ensure that either an `associate_id` is provided or all payer details (`payer_name`, `payer_surname`, and `payer_email`) are filled out. This ensures that there is always sufficient information about the payer.

### 2. Leagues & events domain

- `leagues`: Stores information about leagues in the PauperWave community.

```sql
-- 1. Table definition
create table public.leagues (
  id bigint generated by default as identity not null,
  uuid uuid not null default gen_random_uuid (),
  
  name text not null,
  status text not null,

  season text null,
  starts_at date null,
  ends_at date null,
  ruleset_id bigint null,
  
  constraint leagues_pkey primary key (id),
  constraint leagues_uuid_key unique (uuid),
  constraint fk_leagues_ruleset_id foreign KEY (ruleset_id) references rulesets (id) on delete set null,
  constraint leagues_ruleset_id_fkey foreign KEY (ruleset_id) references rulesets (id) on update CASCADE on delete RESTRICT
) TABLESPACE pg_default;

-- 2. Indexes for faster lookups
create index IF not exists idx_leagues_ruleset_id
  on public.leagues using btree (ruleset_id) TABLESPACE pg_default;
```

- `events`: Manages events related to PauperWave. An event can host multiple tournaments.

```sql
-- 1. Table definition
create table public.events (
  id bigint generated by default as identity not null,
  uuid uuid not null default gen_random_uuid (),
  league_uuid uuid null,
  organizer_uuid uuid not null,
  
  status text not null,
  name text not null,
  location text null,
  companion_app_code text null,
  
  created_at timestamp with time zone not null,

  constraint events_pkey primary key (id),
  constraint events_uuid_key unique (uuid),
  constraint events_league_uuid_fkey foreign KEY (league_uuid) references leagues (uuid) on update CASCADE on delete CASCADE,
  constraint events_location_fkey foreign KEY (location) references event_locations (name)
) TABLESPACE pg_default;

-- 2. Indexes for faster lookups
create index IF not exists idx_events_location
  on public.events using btree (location) TABLESPACE pg_default;
create index IF not exists idx_events_location
  on public.events using btree (location) TABLESPACE pg_default;
```

Nota: `organizer_uuid uuid not null` aggiunto all'ultimo, da integrare nella struttura dati di creazione/modifica eventi.

- `event_attendees`: Tracks attendees for PauperWave events.

```sql
-- 1. Table definition
create table public.event_attendees (
  id bigint generated by default as identity not null,
  uuid uuid not null default gen_random_uuid (),
  player_uuid uuid not null,
  event_uuid uuid not null,

  role text not null default 'player'::text,
  status text not null default 'registered'::text,
  joined_at timestamp with time zone not null default now(),
  
  constraint event_participants_pkey primary key (id),
  constraint event_attendees_uuid_key unique (uuid),

  -- Ensure a player can register only once per event
  constraint event_attendees_unique unique (event_uuid, player_uuid),

  constraint event_attendees_event_uuid_fkey foreign KEY (event_uuid)
    references events (uuid)
    on update CASCADE
    on delete CASCADE,

  constraint event_attendees_player_uuid_fkey foreign KEY (player_uuid)
    references players (uuid)
    on update CASCADE
    on delete CASCADE,
  
  constraint event_participants_role_check check (
    (
      role = any (
        array['player'::text, 'organizer'::text, 'judge'::text]
      )
    )
  ),
  constraint event_participants_status_check check (
    (
      status = any (
        array[
          'registered'::text,
          'checked_in'::text,
          'participated'::text,
          'no-show'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

-- 2. Indexes for faster lookups

-- Lookup by public-facing UUID
create index IF not exists idx_event_participants_player_uuid
  on public.event_attendees
  using btree (player_uuid) TABLESPACE pg_default;

-- All participants for an event
create index if not exists idx_event_participants_event_uuid
  on public.event_attendees (event_uuid);

-- All players for an event
create index if not exists idx_event_attendees_event_uuid
  on public.event_attendees (event_uuid);

-- All events for a player
create index if not exists idx_event_attendees_player_uuid
  on public.event_attendees (player_uuid);

-- 3. Enable Row-Level Security
ALTER TABLE public.event_attendees ENABLE ROW LEVEL SECURITY;
```

- `event_locations`: Stores locations for PauperWave events.

```sql
-- 1. Table definition
create table public.event_locations (
  id bigint generated by default as identity not null,
  uuid uuid not null default gen_random_uuid (),

  name text not null,
  address text not null,
  city text not null,
  province text not null,
  country text not null default 'Italy'::text,
  postal_code text not null,
  phone text null,
  email text null,
  website text null,

  constraint locations_pkey primary key (id),
  constraint locations_name_key unique (name),
  constraint locations_uuid_key unique (uuid)
) TABLESPACE pg_default;
```

### 3. Tournaments domain

- `tournaments`: Stores information about tournaments within events. Each tournament:
    - belongs to a single event,
    - consists of multiple rounds,
    - can be associated with a league or exist as a standalone tournament;
    - includes tournament-specific details such as format, status, datetime, and description.

```sql
-- 1. Table definition
create table public.tournaments (
  id bigint generated by default as identity not null, 
  
  uuid uuid not null default gen_random_uuid (),
  event_uuid uuid not null,
  league_uuid uuid null,
  
  format text not null,
  name text not null,
  description text null,
  datetime timestamp with time zone null,
  status text not null,
  
  round_count smallint null,
  round_current smallint null,

  constraint tournaments_pkey primary key (uuid),
  constraint tournaments_event_uuid_fkey foreign KEY (event_uuid) references events (uuid)
    on update CASCADE on delete CASCADE,
  constraint tournaments_format_fkey foreign KEY (format) references mtg_formats (name)
    on update CASCADE on delete RESTRICT,
  constraint tournaments_league_uuid_fkey foreign KEY (league_uuid) references leagues (uuid)
    on update CASCADE on delete CASCADE
) TABLESPACE pg_default;

-- 2. Indexes for faster lookups
create index IF not exists idx_tournaments_format
  on public.tournaments using btree (format) TABLESPACE pg_default;

create index IF not exists idx_tournaments_event_uuid
  on public.tournaments using btree (event_uuid) TABLESPACE pg_default;

create index IF not exists idx_tournaments_league_uuid
  on public.tournaments using btree (league_uuid) TABLESPACE pg_default;

-- 3. Enable Row-Level Security
ALTER TABLE public.tournaments ENABLE ROW LEVEL SECURITY;
```

<!-- - `tournament_rounds`: Manages rounds within tournaments.
- `tournament_pairings`: Tracks pairings for matches in tournament rounds.
- `tournament_positions`: Manages player positions within tournament rounds.
- `tournament_results`: Records results of matches in tournament rounds.
- `tournament_scores`: Tracks scores for players in tournaments. -->

- `tournament_registrations`: Stores registration records for tournaments. Each registration:
    - links a player to a specific tournament,
    - includes registration details such as date, status, and payment info if relevant.

Main queries I'll likely run into the project:
1. Look up a registration by its registration_uuid (e.g. when a player/admin clicks a link to approve/remove).
2. Get all registrations for a tournament (common for admins).
3. Get all registrations for a player (common for players viewing their history).
4. (Optional) Check if a player is already registered for a tournament â€” already enforced by the unique constraint, but an index helps performance.

```sql
-- 1. Table definition
create table public.tournament_registrations (
  id bigint generated by default as identity primary key,
  uuid uuid not null default gen_random_uuid (),
  tournament_uuid uuid not null,
  player_uuid uuid not null,

  registered_at timestamp without time zone default now(),
  status text default 'pending',
  
  constraint tournament_registrations_player_uuid_fkey
    foreign key (player_uuid)
    references players (uuid)
    on update cascade
    on delete cascade,
  constraint tournament_registrations_tournament_uuid_fkey
    foreign key (tournament_uuid)
    references tournaments (uuid)
    on update cascade
    on delete cascade,
  constraint tournament_registrations_unique_player_per_tournament
    unique (player_uuid, tournament_uuid)
) tablespace pg_default;

-- 2. Indexes for faster lookups

-- For fast lookups by public-facing UUID
create index if not exists idx_tournament_registrations_uuid
  on public.tournament_registrations (registration_uuid);

-- For querying all registrations of a tournament
create index if not exists idx_tournament_registrations_tournament
  on public.tournament_registrations (tournament_uuid);

-- For querying all registrations of a player
create index if not exists idx_tournament_registrations_player
  on public.tournament_registrations (player_uuid);

-- Optional: composite index to speed up lookups of "is this player in this tournament?"
create unique index if not exists idx_tournament_registrations_player_tournament
  on public.tournament_registrations (player_uuid, tournament_uuid);

-- 3. Enable Row-Level Security
ALTER TABLE public.tournament_registrations ENABLE ROW LEVEL SECURITY;
```

- `tournament_standings`: Stores the results and rankings of tournament participants. Each record:
    - references a tournament and a player;
    - includes standing details such as `rank`, `points`, and any relevant tiebreakers;
    - Reflects the outcome of all rounds within the tournament.

```sql
-- 1. Table definition
create table public.tournament_standings (
  id bigint generated by default as identity not null,
  uuid uuid not null default gen_random_uuid (),
  registration_uuid uuid not null,
  player_uuid uuid not null,
  
  player_score bigint null,
  player_rank bigint null,
  player_victories bigint null,
  votes_brew_received bigint null,
  votes_play_received bigint null,
  
  constraint standings_pkey primary key (id),
  constraint tournament_standings_player_uuid_fkey foreign KEY (player_uuid) references players (uuid) on delete RESTRICT,
  constraint tournament_standings_registration_uuid_fkey foreign KEY (registration_uuid) references tournament_registrations (uuid) on delete CASCADE,
) TABLESPACE pg_default;

-- 2. Indexes for faster lookups
create index IF not exists idx_tournament_standings_player_uuid
  on public.tournament_standings
  using btree (player_uuid);

-- 3. Enable Row-Level Security
ALTER TABLE public.tournament_standings ENABLE ROW LEVEL SECURITY;
```

### 4. Players domain

- `players`: Stores information about individual players. Each player may participate in tournaments, register for events, and have associated decks and preferred formats.

```sql
-- 1. Table definition
create table public.player_formats (
  id bigint generated by default as identity not null, -- numeric reference
  format_name text not null,
  player_uuid uuid not null,
  constraint players_formats_pkey primary key (id, format_name),
  constraint unique_player_format unique (player_uuid, format_name),
  constraint player_formats_id_fkey foreign KEY (id) references players (id) on delete CASCADE,
  constraint player_formats_id_fkey1 foreign KEY (id) references players (id) on update CASCADE on delete CASCADE,
  constraint fk_players_formats_format_name foreign KEY (format_name) references mtg_formats (name) on delete CASCADE,
  constraint players_formats_player_uuid_fkey foreign KEY (player_uuid) references players (uuid) on delete RESTRICT,
  constraint players_formats_format_name_fkey foreign KEY (format_name) references mtg_formats (name) on update CASCADE on delete RESTRICT,
  constraint fk_players_formats_player_uuid foreign KEY (player_uuid) references players (uuid) on delete CASCADE
) TABLESPACE pg_default;

-- 2. Indexes for faster lookups
create index IF not exists idx_players_formats_player_id
  on public.player_formats
  using btree (id);

create index IF not exists idx_players_formats_player_uuid
  on public.player_formats
  using btree (player_uuid);

create index IF not exists idx_players_formats_format_name
  on public.player_formats
  using btree (format_name);

-- 3. Enable Row-Level Security
ALTER TABLE public.player_formats ENABLE ROW LEVEL SECURITY;
```

- `player_formats`: Maps players to the Magic formats they play. Each record:
    - references a `player` and a `mtg_format`;
    - indicates which formats a player is active.

```sql
-- 1. Table definition
create table public.player_formats (
  id bigint generated by default as identity not null, -- numeric reference
  
  format_uuid uuid not null,
  player_uuid uuid not null,

  constraint players_formats_pkey primary key (id),
  constraint unique_player_format unique (player_uuid, format_uuid),
  constraint players_formats_player_uuid_fkey foreign KEY (player_uuid) references players (uuid) on delete RESTRICT,
  constraint players_formats_format_uuid_fkey foreign KEY (format_uuid) references mtg_formats (uuid) on update CASCADE on delete RESTRICT,
) TABLESPACE pg_default;
```

- `player_decks`: Stores decks owned or used by players. Each record:
    - simply links players and deck through their uuids;
    - an id is also present for easier referencing in other tables;
    - includes columns such as `id`, `player_uuid`, and `deck_uuid`.

```sql
-- 1. Table definition
CREATE TABLE public.player_decks (
    id bigint generated by default as identity not null, -- numeric reference
    player_uuid uuid NOT NULL, -- references a player
    deck_uuid uuid NOT NULL,   -- references a deck
    CONSTRAINT unique_player_deck UNIQUE (player_uuid, deck_uuid),
    CONSTRAINT fk_player_deck_deck FOREIGN KEY (deck_uuid) 
        REFERENCES public.commander_decks (uuid) ON DELETE CASCADE,
    CONSTRAINT fk_player_deck_player FOREIGN KEY (player_uuid) 
        REFERENCES public.players (uuid) ON DELETE CASCADE
) TABLESPACE pg_default;

-- 2. Indexes for faster lookups
CREATE INDEX IF NOT EXISTS idx_player_deck_player_uuid 
    ON public.player_decks USING btree (player_uuid) TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS idx_player_deck_deck_uuid 
    ON public.player_decks USING btree (deck_uuid) TABLESPACE pg_default;

-- 3. Enable Row-Level Security
ALTER TABLE public.player_decks ENABLE ROW LEVEL SECURITY;

-- 4. RLS policies

-- Players: can manage only their own decks
CREATE POLICY player_own_decks ON public.player_decks
FOR ALL
USING (auth.uid() = player_uuid)
WITH CHECK (auth.uid() = player_uuid);

-- Admins, Organizers, Judges: full access via centralized function
CREATE POLICY management_full_access ON public.player_decks
FOR ALL
USING (public.has_management_permissions(auth.uid()))
WITH CHECK (public.has_management_permissions(auth.uid()));
```

Notes:
- The `player_decks` table uses a composite unique constraint on `(player_uuid, deck_uuid)` to ensure that a player cannot have the same deck listed multiple times.
- `id serial PRIMARY KEY` keeps a simple auto-incrementing identifier.
- Foreign key constraints ensure referential integrity with the `players` and `commander_decks` tables.

### 5. Decks domain

- `commander_decks`:

```sql
-- 1. Table definition
CREATE TABLE public.commander_decks (
    id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL, -- numeric reference
    uuid uuid NOT NULL DEFAULT gen_random_uuid(),
    name text NULL,
    combo_name text NULL,
    decks_archetypes_id uuid NULL,
    commander_1_name text NOT NULL,
    commander_2_name text NULL,
    companion_name text NULL DEFAULT ''::text,
    decklist_url text NULL DEFAULT ''::text,
    CONSTRAINT commander_decks_pkey PRIMARY KEY (uuid),
    CONSTRAINT decks_commander_uuid_key UNIQUE (uuid),
    CONSTRAINT decks_commander_id_key UNIQUE (id),  -- ensure id is unique
    CONSTRAINT decks_commander_combo_name_fkey FOREIGN KEY (combo_name)
        REFERENCES mtg_color_combinations (combo_name)
        ON UPDATE CASCADE ON DELETE RESTRICT,
    CONSTRAINT fk_decks_commander_archetypes_uuid FOREIGN KEY (decks_archetypes_id)
        REFERENCES deck_archetypes (uuid)
        ON DELETE SET NULL
) TABLESPACE pg_default;

-- 2. Indexes for faster lookups
CREATE INDEX IF NOT EXISTS idx_decks_commander_combo_name
ON public.commander_decks USING btree (combo_name) TABLESPACE pg_default;

-- 3. Enable Row-Level Security
ALTER TABLE public.commander_decks ENABLE ROW LEVEL SECURITY;

-- Admins, Organizers, Judges can manage all decks
CREATE POLICY management_full_access ON public.commander_decks
FOR ALL
USING (public.has_management_permissions(auth.uid()))
WITH CHECK (public.has_management_permissions(auth.uid()));
```

- `deck_archetypes`:

```sql
create table public.deck_archetypes (
    id bigint generated by default as identity not null, -- numeric reference
    uuid uuid not null default gen_random_uuid (),
    name text not null,
    description text null,
    constraint deck_archetypes_pkey primary key (uuid),
    constraint deck_archetypes_id_key unique (id),
    constraint deck_archetypes_uuid_key unique (uuid),
    constraint decks_archetypes_name_key unique (name)
) TABLESPACE pg_default;

ALTER TABLE public.commander_decks ENABLE ROW LEVEL SECURITY;

CREATE POLICY players_can_see ON public.deck_archetypes
FOR SELECT
USING (true);

-- Only admins, organizers, judges can manage archetypes
CREATE POLICY management_full_access ON public.deck_archetypes
FOR ALL
USING (public.has_management_permissions(auth.uid()))
WITH CHECK (public.has_management_permissions(auth.uid()));
```

### 6. MTG reference data

- `mtg_formats`:

```sql
-- 1. Table definition
create table public.mtg_formats (
  id bigint generated by default as identity not null,
  uuid uuid not null default gen_random_uuid (),
  
  name text not null,
  description text null default ''::text,
  website_url text null,

  sanctioned boolean not null,
  category text not null,
  platform text[] null,

  deck_size smallint null,
  is_multiplayer boolean null default false,
  min_players smallint null,
  max_players smallint null,
  game_duration smallint null,

  constraint mtg_formats_pkey primary key (id),
  constraint mtg_formats_name_key unique (name),
  constraint mtg_formats_uuid_key unique (uuid)
) TABLESPACE pg_default;

-- 2. Indexes for faster lookups
```

- `mtg_color_combinations`:

```sql
-- 1. Table definition
create table public.mtg_color_combinations (
  id bigint generated by default as identity not null,
  uuid uuid not null default gen_random_uuid (),
  
  combo_name text not null,
  mana_array text[] not null,
  primary_mechanics text[] null,

  constraint mtg_color_combinations_pkey primary key (id),
  constraint mtg_color_combinations_combo_name_key unique (combo_name),
  constraint mtg_color_combinations_mana_array_key unique (mana_array),
  constraint mtg_color_combinations_uuid_key unique (uuid)
) TABLESPACE pg_default;

-- 2. Indexes for faster lookups
create index IF not exists idx_mtg_color_combinations_mana_array
  on public.mtg_color_combinations using btree (mana_array) TABLESPACE pg_default
```

### 7. Rulesets domain

- `rulesets`:

```sql
-- 1. Table definition
create table public.rulesets (
  id bigint generated by default as identity not null,
  uuid uuid null default gen_random_uuid (),

  label text not null,
  description text null,
  
  constraint rulesets_pkey primary key (id)
) TABLESPACE pg_default;

-- 2. Indexes for faster lookups
create index IF not exists idx_rulesets_label
  on public.rulesets using btree (label) TABLESPACE pg_default;
```

- `ruleset__descriptions`:

```sql
-- 1. Table definition
create table public.ruleset__descriptions (
  id bigint generated by default as identity not null,
  
  category text not null,
  description text not null,
  
  constraint rulesets_description_pkey primary key (id),
  constraint rulesets_descriptions_category_key unique (category)
) TABLESPACE pg_default;

-- 2. Indexes for faster lookups
create index IF not exists idx_rulesets_descriptions_category
  on public.ruleset__descriptions using btree (category) TABLESPACE pg_default;

-- 3. Enable Row-Level Security
ALTER TABLE public.ruleset__descriptions ENABLE ROW LEVEL SECURITY;
```

- `ruleset__points`:

```sql
-- 1. Table definition
create table public.ruleset__points (
  id bigint generated by default as identity not null,
  ruleset_id bigint not null,
  category text not null,
  points smallint not null,
  constraint rulesets_points_pkey primary key (id),
  constraint fk_rulesets_points_ruleset_id foreign KEY (ruleset_id) references rulesets (id) on delete CASCADE,
  constraint rulesets_points_category_fkey foreign KEY (category) references ruleset__descriptions (category) on update CASCADE on delete RESTRICT,
  constraint rulesets_points_ruleset_id_fkey foreign KEY (ruleset_id) references rulesets (id) on update CASCADE on delete RESTRICT
) TABLESPACE pg_default;

-- 2. Indexes for faster lookups
create index IF not exists idx_rulesets_points_ruleset_id
  on public.ruleset__points using btree (ruleset_id) TABLESPACE pg_default;
create index IF not exists idx_rulesets_points_category
  on public.ruleset__points using btree (category) TABLESPACE pg_default;

-- 3. Enable Row-Level Security
ALTER TABLE public.ruleset__points ENABLE ROW LEVEL SECURITY;
```

### 8. Users & roles domain

- `user_roles`:

```sql
-- 1. Table definition
create table public.user_roles (
  id uuid not null default gen_random_uuid (),
  user_id uuid not null,
  role public.app_role not null,
  created_at timestamp with time zone null default now(),
  constraint user_roles_pkey primary key (id),
  constraint user_roles_user_id_role_key unique (user_id, role),
  constraint user_roles_user_id_fkey foreign KEY (user_id) references auth.users (id) on delete CASCADE
) TABLESPACE pg_default;

-- 2. Indexes for faster lookups
create index IF not exists idx_user_roles_user_id
  on public.user_roles using btree (user_id) TABLESPACE pg_default;
create index IF not exists idx_user_roles_role
  on public.user_roles using btree (role) TABLESPACE pg_default;

-- 3. Enable Row-Level Security
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
```